/* Generated by RuntimeBrowser.
   Image: /System/Library/PrivateFrameworks/iWorkImport.framework/iWorkImport
 */

/* RuntimeBrowser encountered one or more ivar type encodings for a function pointer. 
   The runtime does not encode function signature information.  We use a signature of: 
           "int (*funcName)()",  where funcName might be null. 
 */

@interface TSDBezierPath : NSObject <NSCopying, NSCoding> {
    int sfr_elementCount;
    int sfr_elementMax;
    struct PATHSEGMENT { unsigned int x1 : 4; unsigned int x2 : 28; struct CGPoint { float x_3_1_1; float x_3_1_2; } x3; } *sfr_head;
    float *sfr_elementLength;
    float sfr_totalLength;
    int sfr_lastSubpathIndex;
    void *sfr_extraSegments;
    float sfr_lineWidth;
    struct CGRect { 
        struct CGPoint { 
            float x; 
            float y; 
        } origin; 
        struct CGSize { 
            float width; 
            float height; 
        } size; 
    } sfr_controlPointBounds;
    float sfr_miterLimit;
    float sfr_flatness;
    float *sfr_dashedLinePattern;
    unsigned int sfr_dashedLineCount;
    float sfr_dashedLinePhase;
    void *sfr_path;
    int sfr_extraSegmentCount;
    int sfr_extraSegmentMax;
    struct { 
        unsigned int sfr_flags : 8; 
        unsigned int sfr_pathState : 2; 
        unsigned int sfr_calculatedLengths : 1; 
        unsigned int sfr_unused : 21; 
    } sfr_bpFlags;
}

@property(readonly) BOOL isCompound;
@property(readonly) BOOL isSelfIntersecting;
@property(readonly) BOOL isOpen;
@property(readonly) BOOL isLineSegment;
@property(readonly) BOOL isEffectivelyClosed;
@property(readonly) BOOL containsClosePathElement;

+ (float)defaultLineWidth;
+ (void)setDefaultLineWidth:(float)arg1;
+ (unsigned int)defaultLineJoinStyle;
+ (void)setDefaultLineJoinStyle:(unsigned int)arg1;
+ (unsigned int)defaultLineCapStyle;
+ (void)setDefaultLineCapStyle:(unsigned int)arg1;
+ (unsigned int)defaultWindingRule;
+ (void)setDefaultWindingRule:(unsigned int)arg1;
+ (float)defaultFlatness;
+ (void)setDefaultFlatness:(float)arg1;
+ (float)defaultMiterLimit;
+ (void)setDefaultMiterLimit:(float)arg1;
+ (void)strokeLineFromPoint:(struct CGPoint { float x1; float x2; })arg1 toPoint:(struct CGPoint { float x1; float x2; })arg2;
+ (void)clipRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
+ (void)strokeRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
+ (id)bezierPathWithStart:(struct CGPoint { float x1; float x2; })arg1 end:(struct CGPoint { float x1; float x2; })arg2;
+ (void)setWindingRule:(unsigned int)arg1;
+ (unsigned int)windingRule;
+ (void)fillRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
+ (void)initialize;
+ (void)setFlatness:(float)arg1;
+ (float)flatness;
+ (void)setMiterLimit:(float)arg1;
+ (float)miterLimit;
+ (void)setLineJoinStyle:(unsigned int)arg1;
+ (unsigned int)lineJoinStyle;
+ (void)setLineCapStyle:(unsigned int)arg1;
+ (unsigned int)lineCapStyle;
+ (void)setLineWidth:(float)arg1;
+ (float)lineWidth;
+ (id)bezierPathWithCGPath:(struct CGPath { }*)arg1;
+ (id)bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1 cornerRadius:(float)arg2;
+ (id)bezierPathWithOvalInRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
+ (id)bezierPathWithRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
+ (id)bezierPath;
+ (id)tracedPathForInstantAlphaBinaryBitmap:(id)arg1 pointSpacing:(float)arg2;
+ (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })p_pathToBounds:(struct Path { int x1; int x2; int x3; struct path_descr {} *x4; int x5; int x6; boolx7; boolx8; int x9; int x10; int x11; char *x12; }*)arg1;
+ (id)smoothBezierPath:(id)arg1 withThreshold:(float)arg2;
+ (id)exteriorOfBezierPath:(id)arg1;
+ (id)appendBezierPaths:(id)arg1;
+ (id)excludeBezierPaths:(id)arg1;
+ (id)p_pathToBezier:(struct Path { int x1; int x2; int x3; struct path_descr {} *x4; int x5; int x6; boolx7; boolx8; int x9; int x10; int x11; char *x12; }*)arg1;
+ (struct Path { int x1; int x2; int x3; struct path_descr {} *x4; int x5; int x6; boolx7; boolx8; int x9; int x10; int x11; char *x12; }*)p_bezierToPath:(id)arg1;
+ (id)p_booleanWithBezierPaths:(id)arg1 operation:(int)arg2;
+ (id)bezierPathWithConvexHullOfPoints:(struct CGPoint { float x1; float x2; }*)arg1 count:(unsigned long)arg2;
+ (id)intersectBezierPaths:(id)arg1;
+ (id)subtractBezierPaths:(id)arg1;
+ (id)outlineBezierPath:(id)arg1;
+ (id)outlineBezierPath:(id)arg1 withThreshold:(float)arg2;
+ (id)uniteBezierPaths:(id)arg1;
+ (id)tracedPathForImage:(struct CGImage { }*)arg1 alphaThreshold:(float)arg2 pointSpacing:(float)arg3;
+ (id)outsideEdgeOfBezierPath:(id)arg1;

- (id)pressure;
- (id)initWithArchive:(const struct Path { int (**x1)(); struct UnknownFieldSet { struct vector<google::protobuf::UnknownField, std::__1::allocator<google::protobuf::UnknownField> > {} *x_2_1_1; } x2; struct RepeatedPtrField<TSP::Path_Element> { void **x_3_1_1; int x_3_1_2; int x_3_1_3; int x_3_1_4; } x3; int x4; unsigned int x5[1]; }*)arg1;
- (void)_addPathSegment:(int)arg1 point:(struct CGPoint { float x1; float x2; })arg2;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1 startAngle:(float)arg2 swingAngle:(float)arg3 angleType:(int)arg4 startNewPath:(BOOL)arg5;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1 startRadialVector:(struct CGPoint { float x1; float x2; })arg2 endRadialVector:(struct CGPoint { float x1; float x2; })arg3 angleSign:(int)arg4 startNewPath:(BOOL)arg5;
- (id)initWithCString:(const char *)arg1;
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint { float x1; float x2; })arg1 toPoint:(struct CGPoint { float x1; float x2; })arg2 radius:(float)arg3;
- (void)appendBezierPathWithPoints:(struct CGPoint { float x1; float x2; }*)arg1 count:(int)arg2;
- (void)setAssociatedPoints:(struct CGPoint { float x1; float x2; }*)arg1 atIndex:(int)arg2;
- (float)lengthToElement:(int)arg1;
- (float)lengthOfElement:(int)arg1;
- (BOOL)isClockwise;
- (BOOL)isCircular;
- (BOOL)isRectangular;
- (id)_copyFlattenedPath;
- (id)bezierPathByFlatteningPath;
- (void)relativeCurveToPoint:(struct CGPoint { float x1; float x2; })arg1 controlPoint1:(struct CGPoint { float x1; float x2; })arg2 controlPoint2:(struct CGPoint { float x1; float x2; })arg3;
- (void)relativeLineToPoint:(struct CGPoint { float x1; float x2; })arg1;
- (void)relativeMoveToPoint:(struct CGPoint { float x1; float x2; })arg1;
- (void)_appendArcSegmentWithCenter:(struct CGPoint { float x1; float x2; })arg1 radius:(double)arg2 angle1:(double)arg3 angle2:(double)arg4;
- (void)transformUsingAffineTransform:(struct CGAffineTransform { float x1; float x2; float x3; float x4; float x5; float x6; })arg1;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { float x1; float x2; })arg1 radius:(float)arg2 startAngle:(float)arg3 endAngle:(float)arg4;
- (void)_appendToPath:(id)arg1;
- (void)calculateLengths;
- (float)calculateLengthOfElement:(int)arg1;
- (unsigned int)elementAtIndex:(int)arg1 allPoints:(struct CGPoint { float x1; float x2; }*)arg2;
- (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })controlPointBounds;
- (unsigned int)elementAtIndex:(int)arg1 associatedPoints:(struct CGPoint { float x1; float x2; }*)arg2;
- (BOOL)isFlat;
- (void)_doPath;
- (void)curveToPoint:(struct CGPoint { float x1; float x2; })arg1 controlPoint1:(struct CGPoint { float x1; float x2; })arg2 controlPoint2:(struct CGPoint { float x1; float x2; })arg3;
- (void)flattenIntoPath:(id)arg1;
- (void)subdivideBezierWithFlatness:(float)arg1 startPoint:(struct CGPoint { float x1; float x2; })arg2 controlPoint1:(struct CGPoint { float x1; float x2; })arg3 controlPoint2:(struct CGPoint { float x1; float x2; })arg4 endPoint:(struct CGPoint { float x1; float x2; })arg5;
- (void)_deviceClosePath;
- (void)_deviceCurveToPoint:(struct CGPoint { float x1; float x2; })arg1 controlPoint1:(struct CGPoint { float x1; float x2; })arg2 controlPoint2:(struct CGPoint { float x1; float x2; })arg3;
- (void)_deviceLineToPoint:(struct CGPoint { float x1; float x2; })arg1;
- (void)_deviceMoveToPoint:(struct CGPoint { float x1; float x2; })arg1;
- (void)setWindingRule:(unsigned int)arg1;
- (unsigned int)windingRule;
- (unsigned int)elementAtIndex:(int)arg1;
- (int)elementCount;
- (BOOL)isOpen;
- (void)setFlatness:(float)arg1;
- (float)flatness;
- (void)setMiterLimit:(float)arg1;
- (float)miterLimit;
- (void)setLineJoinStyle:(unsigned int)arg1;
- (unsigned int)lineJoinStyle;
- (void)setLineCapStyle:(unsigned int)arg1;
- (unsigned int)lineCapStyle;
- (void)setLineWidth:(float)arg1;
- (float)lineWidth;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { float x1; float x2; })arg1 radius:(float)arg2 startAngle:(float)arg3 endAngle:(float)arg4 clockwise:(BOOL)arg5;
- (void)appendBezierPathWithOvalInRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
- (void)appendBezierPathWithRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1;
- (void)appendBezierPath:(id)arg1;
- (void)lineToPoint:(struct CGPoint { float x1; float x2; })arg1;
- (void)stroke;
- (void)fill;
- (void)getLineDash:(float*)arg1 count:(int*)arg2 phase:(float*)arg3;
- (void)setLineDash:(const float*)arg1 count:(int)arg2 phase:(float)arg3;
- (BOOL)containsPoint:(struct CGPoint { float x1; float x2; })arg1;
- (struct CGPoint { float x1; float x2; })currentPoint;
- (BOOL)isEmpty;
- (id)bezierPathByReversingPath;
- (void)removeAllPoints;
- (id)copyWithZone:(struct _NSZone { }*)arg1;
- (void)addClip;
- (struct CGPath { }*)CGPath;
- (void)closePath;
- (void)moveToPoint:(struct CGPoint { float x1; float x2; })arg1;
- (BOOL)isEqual:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (float)length;
- (id)description;
- (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })bounds;
- (void)dealloc;
- (void)finalize;
- (id)init;
- (const char *)cString;
- (id)bezierPathByFittingCurve;
- (id)bezierPathByFittingCurve:(id)arg1;
- (struct CGPoint { float x1; float x2; })roundPoint:(struct CGPoint { float x1; float x2; })arg1 inContext:(struct CGContext { }*)arg2 strokeWidth:(int)arg3;
- (id)pathByWobblingByUpTo:(float)arg1 subdivisions:(unsigned int)arg2;
- (void)clearStroke:(struct CGContext { }*)arg1;
- (id)bezierPathByOffsettingPath:(float)arg1 joinStyle:(unsigned int)arg2 withThreshold:(float)arg3;
- (id)p_beziersFromSegmentIntersections:(id)arg1;
- (id)p_pathAsSegments;
- (id)bezierPathByRemovingNearlyEqualPoints;
- (struct CGPoint { float x1; float x2; })pointAlongPathAtPercentage:(float)arg1;
- (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })_addMitersFromSegments:(id)arg1 toRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg2;
- (BOOL)isSelfIntersecting;
- (void)alignBoundsToOrigin;
- (float)yValueFromXValue:(float)arg1;
- (id)pathBySplittingAtPointOnPath:(struct CGPoint { float x1; float x2; })arg1;
- (id)p_aliasedPathInContext:(struct CGContext { }*)arg1 viewScale:(float)arg2 effectiveStrokeWidth:(float)arg3;
- (id)subtractBezierPath:(id)arg1;
- (BOOL)containsClosePathElement;
- (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })boundsIncludingStrokeWidth:(float)arg1 joinStyle:(unsigned int)arg2 capStyle:(unsigned int)arg3 miterLimit:(float)arg4 needsToExtendJoins:(BOOL)arg5;
- (float)yValueFromXValue:(float)arg1 elementIndex:(int*)arg2 parametricValue:(float*)arg3;
- (BOOL)isCompound;
- (BOOL)pointOnPath:(struct CGPoint { float x1; float x2; })arg1 tolerance:(float)arg2;
- (BOOL)isDiamond;
- (BOOL)isTriangular;
- (id)aliasedPathInContext:(struct CGContext { }*)arg1 effectiveStrokeWidth:(float)arg2;
- (id)bezierPathByRemovingRedundantElements;
- (BOOL)isEffectivelyClosed;
- (void)takeAttributesFromStroke:(id)arg1;
- (float)distanceToPoint:(struct CGPoint { float x1; float x2; })arg1 elementIndex:(unsigned int*)arg2 tValue:(float*)arg3 threshold:(float)arg4;
- (BOOL)isLineSegment;
- (void)recursiveSubdivideOntoPath:(id)arg1 withScaling:(struct { float x1; float x2; })arg2 into:(id)arg3;
- (void)recursiveSubdivideOntoPath:(id)arg1 into:(id)arg2;
- (float)curvatureAt:(float)arg1;
- (struct CGPoint { float x1; float x2; })myGradientAt:(float)arg1;
- (struct CGPoint { float x1; float x2; })transformedTotalCoordinate:(struct CGPoint { float x1; float x2; })arg1 inElement:(int)arg2 withPressure:(id)arg3;
- (struct CGPoint { float x1; float x2; })transformedCoordinate:(struct CGPoint { float x1; float x2; })arg1 withPressure:(id)arg2;
- (struct CGPoint { float x1; float x2; })gradientAt:(float)arg1;
- (struct CGPoint { float x1; float x2; })nearestAngleOnPathToLine:(struct CGPoint { float x1; float x2; }[2])arg1;
- (struct CGPoint { float x1; float x2; })nearestPointOnPathToLine:(struct CGPoint { float x1; float x2; }[2])arg1;
- (id)copyFromSegment:(int)arg1 t:(float)arg2 toSegment:(int)arg3 t:(float)arg4;
- (void)appendBezierPath:(id)arg1 fromSegment:(int)arg2 toSegment:(int)arg3;
- (void)addIntersectionsWithLine:(struct CGPoint { float x1; float x2; }[2])arg1 to:(id)arg2;
- (void)addIntersectionsWithPath:(id)arg1 to:(id)arg2;
- (void)getStartPoint:(struct CGPoint { float x1; float x2; }*)arg1 andEndPoint:(struct CGPoint { float x1; float x2; }*)arg2;
- (void)recursiveSubdivideOntoPath:(id)arg1 withScaling:(struct { float x1; float x2; })arg2 inElementRange:(struct _NSRange { unsigned int x1; unsigned int x2; })arg3 into:(id)arg4;
- (struct CGPoint { float x1; float x2; })myGradientAt:(float)arg1 fromElement:(int)arg2;
- (struct CGPoint { float x1; float x2; })transformedTotalCoordinate:(struct CGPoint { float x1; float x2; })arg1 betweenElement:(int)arg2 andElement:(int)arg3 withPressure:(id)arg4 getElement:(int*)arg5 getPercentage:(float*)arg6;
- (float)curvatureAt:(float)arg1 fromElement:(int)arg2;
- (float)elementPercentageFromElement:(int)arg1 forOverallPercentage:(float)arg2;
- (struct CGPoint { float x1; float x2; })pointAt:(float)arg1 fromElement:(int)arg2;
- (struct CGPoint { float x1; float x2; })gradientAt:(float)arg1 fromElement:(int)arg2;
- (int)elementPercentage:(float*)arg1 forOverallPercentage:(float)arg2;
- (struct CGPoint { float x1; float x2; })rawGradientAt:(float)arg1 fromElement:(int)arg2;
- (void)appendBezierPath:(id)arg1 fromSegment:(int)arg2 t:(float)arg3 toSegment:(int)arg4 t:(float)arg5 withoutMove:(BOOL)arg6;
- (void)addIntersectionsWithPath:(id)arg1 to:(id)arg2 allIntersections:(BOOL)arg3 reversed:(BOOL)arg4;
- (id)chisel;
- (id)aliasedPathWithViewScale:(float)arg1 effectiveStrokeWidth:(float)arg2;
- (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })boundsIncludingStroke;
- (struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })boundsIncludingTSDStroke:(id)arg1;
- (BOOL)intersectsRect:(struct CGRect { struct CGPoint { float x_1_1_1; float x_1_1_2; } x1; struct CGSize { float x_2_1_1; float x_2_1_2; } x2; })arg1 hasFill:(BOOL)arg2;
- (id)uniteWithBezierPath:(id)arg1;
- (id)outlineStroke;
- (void)addPathToContext:(struct CGContext { }*)arg1;
- (id)intersectBezierPath:(id)arg1;
- (void)saveToArchive:(struct Path { int (**x1)(); struct UnknownFieldSet { struct vector<google::protobuf::UnknownField, std::__1::allocator<google::protobuf::UnknownField> > {} *x_2_1_1; } x2; struct RepeatedPtrField<TSP::Path_Element> { void **x_3_1_1; int x_3_1_2; int x_3_1_3; int x_3_1_4; } x3; int x4; unsigned int x5[1]; }*)arg1;

@end
